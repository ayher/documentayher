## dict
hash 表是非常重要的数据结构，但是 c 语言中并没有这种数据接口，而 redis 则是实用 c 语言写的，无奈的 redis 开发者只能自己动手实现 c 语言的 hash 表，取名 dict。
如果是你，你会怎么设计？如果是我，我会这样
### hash 表的简单实现
众所周知，hash 表就是通过散列函数，把键值 key 映射到表地址中，因此，
1. 我们选择 MurmurHash 作为 hash 算法，至于为什么选择这个，就是因为好。
2. 然后我们需要建立一个数组作为 hash 表本体。
3. hash 表的内容就是一个字符串类型

就这样，一个简单的 hash 表完成了。凡事有好有坏，简单的它有不少问题：
1. 值只能保存字符串，无法保存数值类型
2. 无法解决键冲突
3. 负载因子（负载因子 = 哈希表已保存节点数量 / 哈希表大小）太多太小，影响效率，无法扩容/缩小

虽然有问题，并且问题不小，但是至少有得用，下面我们继续优化
### hash 表的进阶实现
#### 1. 解决键冲突
因为是 key 通过散列函数映射到表地址，所以有可能冲突。我们使用拉链法解决：

1. 把节点作为结构体，结构体内部保存 key 字符串，和 value 值，value 值允许为字符串，和数字
2. 把节点作为结构体，结构体内部有一个 next 指针，如果不同的两个 key 被映射到同一个表地址，就使用头插法，把新节点添加进入节点列表。为什么使用头插法？因为效率高！

这样设计后，就可以解决键冲突的问题。

#### 2. 解决负载因子效率问题
如果 hash 表冲突太多，每次查询都需要遍历节点队列，这将大大影响查询效率，因此，必要的时候，需要对表进扩容。而如果 hash 表键太少，有大量的 hash 表地址未使用，也需要缩小，免得浪费空间。
必要的时间如下：
    1. 没有 BGSAVE 和 BGREWRITEAOF 命令，且负载因子大于等于 1 。
    2. 有 BGSAVE 和 BGREWRITEAOF 命令，且负载因子大于等于 5 。

其中 负载因子 = 哈希表已保存节点数量 / 哈希表大小； 

因为BGSAVE 和 BGREWRITEAOF 命令会启动子进程，而大多数操作系统使用写时复制（copy-on-write）技术（创建一个进程不立刻复制内存，有更改再复制）。所以此时尽可能不修改内存。而如果负载因子太大，不得不执行。

为了判断时机，我们就需要知道 hash 表已使用和总大小。因此，需要使用一个结构体，保存 hash 表已使用和总大小。

时机到了，我们需要对 hash 表进行扩大或者缩小了，新 hash 表大小如下：
    * 扩大的大小 m 为满足下面两个条件的最小值。
        1. m>原 hash 表已使用的大小 * 2
        2. m 为 2^n 次方，n 为自然数。
    * 缩小的大小 m 为满足下面两个条件的最大值。
        1. m>原 hash 表已使用的大小
        2. m 为 2^n 次方，n 为自然数。

确定好了大小，我们就创建一个新的 hash 表，然后遍历旧表，把键值对一一映射到新表。

作为一个 hash 表，他已经很不错了。但是当跑起来时又有问题：
    1. 旧 hash 表映射到新 hash 表需要漫长的时间，而这将导致 hash 表一段时间之内不可用。

#### 渐进式 rehash
一次性把旧表映射到新表慢，就做成异步，在恰当的时间映射。恰当的时机如下：
    * 当客户端对 redis 进行添加、删除、查找和更新操作后映射一个。

时机到了，我们需要同时保存两个 hash 表，还需要记录下 rehash 的进度，所以又使用一个结构体把 两个 hash 表，和 rehash 下标记录下来。每执行一个操作，就映射一个键，当所有都映射完后，使用新 hash 表替换旧 hash 表，即可。

这看起来很完美，但是也有个小问题：如果这个时候有修改操作，会导致映射混乱。那么对于删除，查找，更新会同时在两个表中进行，而新增只会在新 hash 表中进行。

### redis 的 dict 实现
redis 的 dict 就是我上面的实现方法。
```
hash 表节点

typedef struct dictEntry {

    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;

hash 表
typedef struct dictht {

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;

dict 字典
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

} dict;
```
